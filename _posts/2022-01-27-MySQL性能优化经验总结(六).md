---
layout:     post
title:      MySQL性能优化经验总结(六)
subtitle:   MySQL优化锁
date:       2022-01-27
author:     dex0423
header-img: img/post-bg-universe.jpg
catalog: true
tags:
    - MySQL
---


# 锁优化

### innodb 锁优化

Innodb 存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM 的表级锁定的。
- 尽可能让所有的数据检索都通过索引来完成，从而避免Innodb 因为无法通过索引键加锁而升级为表级锁定；
- 合理设计索引，让Innodb 在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他Query 的执行；
- 尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录；
- 尽量控制事务的大小，减少锁定的资源量和锁定时间长度；
- 在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减少MySQL 因为实现事务隔离级别所带来的附加成本；

##### 减少 innodb 死锁产生概率的建议：
- 类似业务模块中，尽可能按照相同的访问顺序来访问，防止产生死锁；
- 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；
- 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；
- 
### MyISAM 锁优化

MyISAM 表锁优化建议优化MyISAM 存储引擎锁定问题的时候，最关键的就是如何让其提高并发度。由于锁定级别是不可能改变的了，所以我们首先需要尽可能让锁定的时间变短，然后就是让可能并发进行的操作尽可能的并发。

##### 缩短锁定时间
  - 尽两减少大的复杂Query，将复杂Query 分拆成几个小的Query 分布进行；
  - 尽可能的建立足够高效的索引，让数据检索更迅速；
  - 尽量让MyISAM 存储引擎的表只存放必要的信息，控制字段类型；
  - 利用合适的机会优化MyISAM 表数据文件；
##### 分离能并行的操作
  配置是Concurrent Insert（并发插入），MyISAM 存储引擎有一个控制是否打开Concurrent Insert 功能的参数选项：concurrent_insert，可以设置为0，1 或者2。三个值的具体说明如下：
  - `set global concurrent_insert=2(always)`，无论MyISAM 存储引擎的表数据文件的中间部分是否存在因为删除数据而留下的空闲空间，都允许在数据文件尾部进行Concurrent Insert;
  - `set global  concurrent_insert=1(auto)`，当MyISAM 存储引擎表数据文件中间不存在空闲空间的时候，可以从文件尾部进行Concurrent Insert;
  - `set global  concurrent_insert=0(never)`，无论MyISAM 存储引擎的表数据文件的中间部分是否存在因为删除数据而留下的空闲空间，都不允许Concurrent Insert。
##### 合理利用读写优先级
  - 如果我们的系统是一个以读为主，而且要优先保证查询性能的话，我们可以通过设置系统参数选项`low_priority_updates=1`，如果我们的系统需要有限保证数据写入的性能的话，则可以不用设置low_priority_updates参数